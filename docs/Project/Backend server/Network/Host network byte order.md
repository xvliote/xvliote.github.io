# **主机字节序VS网络字节序**

## **大端序/小端序**
- 如果数据类型占用的内存空间大于1字节，CPU把数据存放在内存中的方式有两种：
- 大端序（Big Endian）：低位字节存放在高位，高位字节存放在低位
- 小端序（Little Endia）：低位字节存放在低位，高位字节存放在高位
- 假设从内存地址0x00000001处开始存储十六进制数0x12345678，那么
    - Bit-endian（按原来顺序存储）
        <div class="grid" markdown>
        
            0x00000001           0x12 
            0x00000002           0x34
            0x00000003           0x56
            0x00000004           0x78
        </div>
        
    - Little-endian（颠倒顺序储存）
        <div class="grid" markdown>

            0x00000001           0x78
            0x00000002           0x56
            0x00000003           0x34
            0x00000004           0x12
        </div>

- Intel系列的CPU以小端序方式保存数据，其它型号的CPU不一定
- 操作文件的本质是把内存中的数据写入磁盘，在网络编程中，传输数据的本质也是把数据写入文件（socket也是文件描述符）
- 这样的话，字节序不同的计算机之间传输数据，可能会出现问题

## **网络字节序**
- 为了解决不同字节序的计算机之间传输数据的问题，约定采用网络字节序（大端序）
- C语言提供了四个库函数，用于在主机字节序和网络字节序之间转换：
    - `uint16_t htons(uint16_t hostshort);`   //`uint16_t` 2字节的整数 `unsigned short`
    - `uint32_t htonl(uint32_t hostlong); `   // `uint32_t`  4字节的整数 `unsigned int`
    - `uint16_t ntohs(uint16_t netshort);`
    - `uint32_t ntohl(uint32_t netlong);`

    <div class="grid" markdown>
    
        h	                    host（主机）
        to                      转换
        n	                    network（网络）
        s	                    short（2字节，16位的整数）
        l	                    long（4字节，32位的整数）

    </div>

## **IP地址和通讯端口**
- 在计算机中，IPv4的地址用4字节的整数存放，通讯端口用2字节的整数（0-65535）存放

    <div class="grid" markdown>
    
        字符串存储 15字节    整数存储4字节
        192.168.190.134    3232284294    255.255.255.255
        
                192     168      190      134
             11000000 10101000 10111110 10000110
        大端：11000000 10101000 10111110 10000110
        小端：10000110 10111110 10101000 11000000

    </div>

## **处理大小端序**
- 在网络编程中，数据收发的时候有自动转换机制，不需要程序员手动转换，只有向sockaddr_in结体成员变量填充数据时，才需要考虑字节序的问题
