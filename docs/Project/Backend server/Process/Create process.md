## **Linux的0、1和2号进程**

- 整个`linux`系统全部的进程是一个树形结构。
- `0`号进程（系统进程）是所有进程的祖先，它创建了`1`号和`2`号进程。
- `1`号进程（`systemd）`负责执行内核的初始化工作和进行系统配置。
- `2`号进程`（kthreadd）`负责所有内核线程的调度和管理。
- 用`pstree`命令可以查看进程树`（yum -y install psmisc）`
- `pstree -p` 进程编号

## **进程标识**

- 每个进程都有一个非负整数表示的唯一的进程`ID`。虽然是唯一的，但是进程ID可以复用。当一个进程终止后，其进程`ID`就成了复用的候选者
- `Linux`采用延迟复用算法，让新建进程的`ID`不同于最近终止的进程所使用的`ID`。这样防止了新进程被误认为是使用了同一ID的某个已终止的进程
    - pid_t getpid(void);     // 获取当前进程的ID
    - pid_t getppid(void);    // 获取父进程的ID

## **fork()函数**

- 一个现有的进程可以调用fork()函数创建一个新的进程
- `pid_t fork(void);`
- 由`fork()`创建的新进程被称为子进程。子进是父进程的副本，父进程和子进程都从调用`fork()`之后的代码开始执行
- `fork()`函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是`0`，而父进程的返回值则是子进程的进程`ID`
- 子进程获得了父进程数据空间、堆和栈的副本（注意：子进程拥有的是副本，不是和父进程共享）

    - 当调用fork()时，操作系统会为子进程分配一个新的内存空间，并将父进程的内存空间复制到子进程中
    - 这种复制是通过“写时复制”（copy-on-write）机制实现的，也就是说，只有当子进程试图修改这些数据时，才会真正地复制这些数据到子进程的独立空间中
    - 虽然子进程获得了父进程变量bh和message的副本，但是在打印这些变量的地址之前，子进程并没有对它们进行修改。因此，这些变量的地址仍然指向父进程的数据空间。
    - 只有当子进程对这些变量进行修改时，它们的地址才会变得不同，因为这时候子进程会在自己的数据空间中创建这些变量的副本
    - 这意味着父进程和子进程都有相同的代码、数据和堆栈，但它们是独立的进程，拥有不同的PID和内存地址空间。因此，尽管它们执行相同的代码，但它们是两个不同的进程实例
    

- `fork()`之后，父进程和子进程的执行顺序是不确定的

```c++
#include <iostream>
#include <unistd.h>
using namespace std;

int main()
{
  int bh=8;
  string message="我是一只傻傻鸟。";

  pid_t pid=fork();

  if (pid>0)
  { // 父进程将执行这段代码。
    sleep(1);
    cout << "父：pid=" << pid << endl;
    cout << "父：亲爱的" << bh << "号：" << message << endl;
  }
  else
  { // 子进程将执行这段代码。
    bh=3; message="你是一只傻傻鸟。";
    cout << "子：pid=" << pid << endl;
    cout << "子：亲爱的" << bh << "号：" << message << endl;
  }
}
```

## **fork()两种用法**

1. 父进程复制自己，然后，父进程和子进程分别执行不同的代码。这种用法在网络服务程序中很常见，父进程等待客户端的连接请求，当请求到达时，父进程调用`fork()`，让子进程处理些请求，而父进程则继续等待下一个连接请求。
2. 进程要执行另一个程序。这种用法在`Shell`中很常见，子进程从`fork()`返回后立即调用`exec`,`（system()函数）`

```c++
#include <iostream>
#include <unistd.h>
using namespace std;

int main()
{
  if (fork()>0)
  { // 父进程将执行这段代码。
    while (true)
    {
      sleep(1);
      cout << "父进程运行中...\n";
    }
  }
  else
  { // 子进程将执行这段代码。
    sleep(10);
    cout << "子进程开始执行任务...\n";
    execl("/bin/ls","/bin/ls","-lt","/tmp",0); //新进程取代子进程
    cout << "子进程执行任务结束，退出。\n";
  }
}
```

## **共享文件**
- `fork()`的一个特性是在父进程中打开的文件描述符都会被复制到子进程中，父进程和子进程共享同一个文件偏移量
- 如果父进程和子进程写同一描述符指向的文件，但又没有任何形式的同步，那么它们的输出可能会相互混合

```c++
#include <unistd.h>
#include <fstream>
#include <iostream>
using namespace std;

int main() {
  ofstream fout;
  fout.open("/home/Linux/01/a.txt");
  fork();
  for (int i = 0; i < 100; i++)
    fout << "进程ID: " << getpid() << "小小" << i << "x" << endl;
  fout.close();
}
```

## **vfork()函数**
- `vfork()`函数的调用和返回值与`fork()`相同，但两者的语义不同。
- `vfork()`函数用于创建一个新进程，而该新进程的目的是`exec`一个新程序，它不复制父进程的地址空间，因为子进程会立即调用`exec`，于是也就不会使用父进程的地址空间。如果子进程使用了父进程的地址空间，可能会带来未知的结果
- `vfork()`和`fork()`的另一个区别是：`vfork()`保证子进程先运行，在子进程调用`exec`或`exit()`之后父进程才恢复运行
